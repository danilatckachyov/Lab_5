# **Отчёт по лабораторной работе**  
**Тема:** Применение паттернов проектирования в системе учета сотрудников

## Сведения о студенте
**Дата:** 2025-01-XX
**Семестр:** 2 курс 1 семестр
**Группа:** ПИН-Б-О-24-2
**Дисциплина:** Технологии программирования
**Студент:** Ткачев Данила Дмитриевич

---

## Оглавление

1. [Введение](#введение)
2. [Структура проекта](#структура-проекта)
3. [Паттерн 1: Singleton (Одиночка)](#паттерн-1-singleton-одиночка)
4. [Паттерн 2: Factory Method (Фабричный метод)](#паттерн-2-factory-method-фабричный-метод)
5. [Паттерн 3: Strategy (Стратегия)](#паттерн-3-strategy-стратегия)
6. [Паттерн 4: Observer (Наблюдатель)](#паттерн-4-observer-наблюдатель)
7. [Сравнение: До и после применения паттернов](#сравнение-до-и-после-применения-паттернов)
8. [Заключение](#заключение)
9. [Приложения](#приложения)

---

## Введение

### Цель работы
Освоить практическое применение паттернов проектирования для рефакторинга и улучшения кодовой базы системы учета сотрудников. Получить навыки применения различных паттернов для решения типичных задач проектирования ПО.

### Используемые технологии
- **Язык программирования:** Python 3.8+
- **База данных:** SQLite (опционально)
- **Дополнительные библиотеки:** `abc`, `json`, `sqlite3`
- **Инструменты:** Любая IDE, Git

### Реализованные паттерны
В рамках данной работы реализованы следующие паттерны проектирования:
1. **Singleton (Одиночка)** - для управления единственным подключением к базе данных
2. **Factory Method (Фабричный метод)** - для создания объектов сотрудников
3. **Strategy (Стратегия)** - для расчета бонусов сотрудников
4. **Observer (Наблюдатель)** - для системы уведомлений об изменениях

---

## Структура проекта

```
fordanila/
├── src/                          # Исходный код системы
│   ├── core/                     # Основные классы системы
│   │   ├── __init__.py
│   │   ├── abstract_employee.py  # Абстрактный класс AbstractEmployee
│   │   ├── employee.py           # Базовый класс Employee
│   │   ├── department.py         # Класс Department
│   │   ├── company.py            # Класс Company
│   │   └── project.py            # Класс Project
│   ├── employees/                # Классы сотрудников
│   │   ├── __init__.py
│   │   ├── manager.py            # Класс Manager
│   │   ├── developer.py          # Класс Developer
│   │   └── salesperson.py        # Класс Salesperson
│   ├── factories/                # Фабрики (обратная совместимость)
│   │   ├── __init__.py
│   │   └── employee_factory.py   # EmployeeFactory
│   ├── patterns/                 # Реализации паттернов проектирования
│   │   ├── __init__.py
│   │   ├── singleton.py          # Singleton для DatabaseConnection
│   │   ├── factory_method.py     # Factory Method
│   │   ├── strategy.py           # Strategy для расчета бонусов
│   │   └── observer.py          # Observer для системы уведомлений
│   ├── database/                 # Работа с базой данных
│   │   ├── __init__.py
│   │   └── connection.py         # Singleton для подключения к БД
│   └── utils/                    # Вспомогательные модули
│       ├── __init__.py
│       ├── exceptions.py         # Кастомные исключения
│       └── comparators.py         # Компараторы для сортировки
├── examples/                     # Примеры использования
│   ├── demo_part1.py             # Демо Part 1: Инкапсуляция
│   ├── demo_part2.py             # Демо Part 2: Наследование
│   ├── demo_part3.py             # Демо Part 3: Полиморфизм
│   ├── demo_part4.py             # Демо Part 4: Композиция
│   └── demo_patterns.py          # Демо паттернов проектирования
├── data/                         # Данные
│   ├── json/                     # JSON файлы
│   └── csv/                      # CSV отчеты
├── README.md                     # Описание проекта
└── main.py                       # Основной скрипт для запуска
```

---

## Паттерн 1: Singleton (Одиночка)

### Назначение паттерна
Гарантировать, что у класса есть только один экземпляр, и предоставить к нему глобальную точку доступа. В нашем случае это используется для управления единственным подключением к базе данных SQLite.

### Проблема, которую решает паттерн
Без использования Singleton при каждом обращении к базе данных создавалось бы новое подключение, что приводит к:
- Избыточному расходу ресурсов
- Потенциальным проблемам с блокировками базы данных
- Сложности управления транзакциями

### Реализация

```python
class DatabaseConnection:
    """
    Класс для управления единственным подключением к базе данных SQLite.
    
    Реализует паттерн Singleton - гарантирует единственный экземпляр
    подключения в рамках приложения.
    """
    
    _instance: Optional['DatabaseConnection'] = None
    _connection: Optional[sqlite3.Connection] = None
    
    def __new__(cls):
        """
        Создание или возврат единственного экземпляра.
        
        Returns:
            Единственный экземпляр DatabaseConnection
        """
        if cls._instance is None:
            cls._instance = super(DatabaseConnection, cls).__new__(cls)
        return cls._instance
    
    def get_connection(self, db_path: Optional[str] = None) -> sqlite3.Connection:
        """Получить подключение к базе данных."""
        if db_path:
            self._db_path = db_path
        
        if self._connection is None:
            self._connection = sqlite3.connect(
                self._db_path,
                check_same_thread=False
            )
            self._connection.row_factory = sqlite3.Row
            self._create_tables()
        
        return self._connection
```

### Пример использования

```python
# Создаем несколько экземпляров
db1 = DatabaseConnection()
db2 = DatabaseConnection()
db3 = DatabaseConnection.get_instance()

# Проверяем, что все ссылки указывают на один объект
print(f"db1 is db2: {db1 is db2}")  # True
print(f"db1 is db3: {db1 is db3}")  # True

# Получаем подключение
conn1 = db1.get_connection()
conn2 = db2.get_connection()
print(f"Подключения одинаковые: {conn1 is conn2}")  # True
```

### Преимущества
- ✅ Гарантирует единственный экземпляр подключения
- ✅ Экономит ресурсы системы
- ✅ Упрощает управление подключением к БД
- ✅ Обеспечивает централизованный доступ к базе данных

### Недостатки
- ⚠️ Глобальное состояние может усложнить тестирование
- ⚠️ В многопоточных приложениях требуется дополнительная синхронизация

---

## Паттерн 2: Factory Method (Фабричный метод)

### Назначение паттерна
Определить интерфейс для создания объекта, но оставить подклассам решение о том, экземпляр какого класса создавать. Паттерн позволяет инкапсулировать логику создания объектов и делает код более расширяемым.

### Проблема, которую решает паттерн
До применения паттерна создание сотрудников происходило напрямую через конструкторы, что приводило к:
- Дублированию кода создания объектов
- Сложности добавления новых типов сотрудников
- Нарушению принципа открытости/закрытости

### Реализация

```python
class EmployeeFactory(ABC):
    """
    Абстрактная фабрика для создания сотрудников.
    
    Реализует паттерн Factory Method - определяет интерфейс для создания
    объектов, но оставляет подклассам решение о том, какой класс инстанцировать.
    """
    
    @abstractmethod
    def create_employee(self, **kwargs) -> AbstractEmployee:
        """Создать сотрудника."""
        pass


class ManagerFactory(EmployeeFactory):
    """Конкретная фабрика для создания менеджеров."""
    
    def create_employee(self, **kwargs) -> Manager:
        return Manager(
            id=kwargs.get("id"),
            name=kwargs.get("name"),
            department=kwargs.get("department"),
            base_salary=kwargs.get("base_salary"),
            bonus=kwargs.get("bonus", 0)
        )


class DeveloperFactory(EmployeeFactory):
    """Конкретная фабрика для создания разработчиков."""
    
    def create_employee(self, **kwargs) -> Developer:
        return Developer(
            id=kwargs.get("id"),
            name=kwargs.get("name"),
            department=kwargs.get("department"),
            base_salary=kwargs.get("base_salary"),
            tech_stack=kwargs.get("tech_stack", []),
            seniority_level=kwargs.get("seniority_level", "junior")
        )


class EmployeeFactoryRegistry:
    """
    Реестр фабрик для удобного создания сотрудников по типу.
    """
    
    _factories: Dict[str, EmployeeFactory] = {
        "manager": ManagerFactory(),
        "developer": DeveloperFactory(),
        "salesperson": SalespersonFactory()
    }
    
    @classmethod
    def create_employee(cls, emp_type: str, **kwargs) -> AbstractEmployee:
        """Создать сотрудника указанного типа через соответствующую фабрику."""
        emp_type = emp_type.lower()
        
        if emp_type == "employee":
            return Employee(...)
        
        if emp_type not in cls._factories:
            raise ValueError(f"Неизвестный тип сотрудника: {emp_type}")
        
        factory = cls._factories[emp_type]
        return factory.create_employee(**kwargs)
```

### Пример использования

```python
# Использование реестра фабрик
manager = EmployeeFactoryRegistry.create_employee(
    "manager",
    id=1,
    name="Иван Иванов",
    department="Управление",
    base_salary=100000,
    bonus=20000
)

# Использование конкретных фабрик
developer_factory = DeveloperFactory()
developer = developer_factory.create_employee(
    id=2,
    name="Анна Сидорова",
    department="Разработка",
    base_salary=80000,
    tech_stack=["Python", "Django"],
    seniority_level="senior"
)
```

### Преимущества
- ✅ Инкапсулирует логику создания объектов
- ✅ Упрощает добавление новых типов сотрудников
- ✅ Соответствует принципу открытости/закрытости
- ✅ Улучшает читаемость и поддерживаемость кода

### Недостатки
- ⚠️ Увеличивает количество классов в системе
- ⚠️ Может быть избыточным для простых случаев

---

## Паттерн 3: Strategy (Стратегия)

### Назначение паттерна
Определить семейство алгоритмов, инкапсулировать каждый из них и сделать их взаимозаменяемыми. Паттерн позволяет изменять алгоритм независимо от клиента, который его использует.

### Проблема, которую решает паттерн
До применения паттерна расчет бонусов был жестко закодирован в классах сотрудников или использовал сложные условные операторы:
- Сложность добавления новых способов расчета бонусов
- Нарушение принципа единственной ответственности
- Сложность тестирования различных стратегий расчета

### Реализация

```python
class BonusStrategy(ABC):
    """
    Абстрактная стратегия для расчета бонусов.
    
    Реализует паттерн Strategy - определяет семейство алгоритмов,
    инкапсулирует каждый из них и делает их взаимозаменяемыми.
    """
    
    @abstractmethod
    def calculate_bonus(self, employee: 'AbstractEmployee', **kwargs) -> float:
        """Рассчитать бонус для сотрудника."""
        pass


class PerformanceBonusStrategy(BonusStrategy):
    """
    Стратегия расчета бонуса на основе производительности.
    
    Бонус = базовая зарплата * коэффициент производительности
    """
    
    def calculate_bonus(self, employee: 'AbstractEmployee', 
                        performance_rating: float = 1.0, **kwargs) -> float:
        base_salary = employee.base_salary
        # Бонус = 10% от базовой зарплаты * рейтинг
        return base_salary * 0.1 * performance_rating


class SeniorityBonusStrategy(BonusStrategy):
    """
    Стратегия расчета бонуса на основе стажа работы.
    """
    
    def calculate_bonus(self, employee: 'AbstractEmployee', 
                        years_of_service: int = 0, **kwargs) -> float:
        base_salary = employee.base_salary
        # Бонус = 5% от базовой зарплаты за каждый год (максимум 50%)
        bonus_percentage = min(years_of_service * 0.05, 0.5)
        return base_salary * bonus_percentage


class BonusCalculator:
    """
    Контекст для использования стратегий расчета бонусов.
    
    Позволяет динамически менять стратегию расчета бонусов.
    """
    
    def __init__(self, strategy: BonusStrategy = None):
        self._strategy = strategy
    
    def set_strategy(self, strategy: BonusStrategy) -> None:
        """Установить стратегию расчета бонусов."""
        self._strategy = strategy
    
    def calculate(self, employee: 'AbstractEmployee', **kwargs) -> float:
        """Рассчитать бонус для сотрудника используя текущую стратегию."""
        if self._strategy is None:
            raise ValueError("Стратегия расчета бонусов не установлена")
        
        return self._strategy.calculate_bonus(employee, **kwargs)
```

### Пример использования

```python
from src.employees.manager import Manager

employee = Manager(
    id=5,
    name="Тестовый Менеджер",
    department="Тест",
    base_salary=100000,
    bonus=0
)

calculator = BonusCalculator()

# Стратегия на основе производительности
calculator.set_strategy(PerformanceBonusStrategy())
performance_bonus = calculator.calculate(employee, performance_rating=1.5)
print(f"Бонус за производительность: {performance_bonus:.2f}")  # 15000.0

# Стратегия на основе стажа
calculator.set_strategy(SeniorityBonusStrategy())
seniority_bonus = calculator.calculate(employee, years_of_service=5)
print(f"Бонус за стаж: {seniority_bonus:.2f}")  # 25000.0

# Стратегия на основе проектов
calculator.set_strategy(ProjectBonusStrategy())
project_bonus = calculator.calculate(
    employee,
    project_count=3,
    completed_projects=2
)
print(f"Бонус за проекты: {project_bonus:.2f}")  # 39000.0
```

### Преимущества
- ✅ Легко добавлять новые стратегии расчета
- ✅ Изолирует алгоритмы от клиентского кода
- ✅ Позволяет динамически менять алгоритм во время выполнения
- ✅ Упрощает тестирование различных стратегий

### Недостатки
- ⚠️ Увеличивает количество классов
- ⚠️ Клиент должен знать о различных стратегиях

---

## Паттерн 4: Observer (Наблюдатель)

### Назначение паттерна
Определить зависимость "один ко многим" между объектами так, чтобы при изменении состояния одного объекта все зависящие от него объекты получали уведомление и обновлялись автоматически.

### Проблема, которую решает паттерн
Без использования паттерна Observer система уведомлений требовала бы:
- Прямого вызова методов уведомления во всех местах изменения данных
- Жесткой связанности между компонентами системы
- Сложности добавления новых типов уведомлений

### Реализация

```python
class Observer(ABC):
    """
    Абстрактный наблюдатель.
    
    Определяет интерфейс для объектов, которые должны быть уведомлены
    об изменениях в субъекте.
    """
    
    @abstractmethod
    def update(self, event_type: str, data: Dict[str, Any]) -> None:
        """Получить уведомление об изменении."""
        pass


class Subject(ABC):
    """
    Абстрактный субъект.
    
    Определяет интерфейс для объектов, за которыми наблюдают.
    """
    
    def __init__(self):
        self._observers: List[Observer] = []
    
    def attach(self, observer: Observer) -> None:
        """Подписать наблюдателя на уведомления."""
        if observer not in self._observers:
            self._observers.append(observer)
    
    def detach(self, observer: Observer) -> None:
        """Отписать наблюдателя от уведомлений."""
        if observer in self._observers:
            self._observers.remove(observer)
    
    def notify(self, event_type: str, data: Dict[str, Any]) -> None:
        """Уведомить всех наблюдателей об изменении."""
        for observer in self._observers:
            observer.update(event_type, data)


class NotificationSystem(Observer):
    """
    Система уведомлений.
    
    Конкретная реализация наблюдателя для отправки уведомлений
    об изменениях в системе.
    """
    
    def __init__(self):
        self._notifications: List[Dict[str, Any]] = []
    
    def update(self, event_type: str, data: Dict[str, Any]) -> None:
        """Обработать уведомление об изменении."""
        notification = {
            "event_type": event_type,
            "data": data,
            "timestamp": self._get_timestamp()
        }
        self._notifications.append(notification)
        self._print_notification(notification)


class EmployeeSubject(Subject):
    """
    Субъект для сотрудников.
    
    Расширяет базовый класс Subject для работы с сотрудниками,
    уведомляя наблюдателей об изменениях зарплаты и других параметров.
    """
    
    def __init__(self, employee: 'AbstractEmployee'):
        super().__init__()
        self._employee = employee
    
    def notify_salary_change(self, old_salary: float, new_salary: float) -> None:
        """Уведомить об изменении зарплаты."""
        self.notify("salary_changed", {
            "employee_id": self._employee.id,
            "employee_name": self._employee.name,
            "old_value": old_salary,
            "new_value": new_salary,
            "message": f"Зарплата сотрудника {self._employee.name} изменена"
        })
```

### Пример использования

```python
from src.employees.manager import Manager

# Создаем сотрудника
employee = Manager(
    id=6,
    name="Наблюдаемый Менеджер",
    department="Отдел А",
    base_salary=95000,
    bonus=10000
)

# Создаем субъект для сотрудника
employee_subject = EmployeeSubject(employee)

# Создаем наблюдателей
notification_system = NotificationSystem()
email_notifier = EmailNotifier("hr@company.com")

# Подписываем наблюдателей
employee_subject.attach(notification_system)
employee_subject.attach(email_notifier)

# Имитируем изменения
old_salary = employee.calculate_salary()
employee.bonus = 15000
new_salary = employee.calculate_salary()
employee_subject.notify_salary_change(old_salary, new_salary)

# Вывод:
# [2025-01-XX XX:XX:XX] Уведомление: salary_changed
#   Сотрудник ID: 6
#   Имя: Наблюдаемый Менеджер
#   Изменение: 105000.0 -> 110000.0
#   Сообщение: Зарплата сотрудника Наблюдаемый Менеджер изменена
```

### Преимущества
- ✅ Слабая связанность между субъектом и наблюдателями
- ✅ Легко добавлять новых наблюдателей
- ✅ Поддержка динамических подписок/отписок
- ✅ Соответствует принципу открытости/закрытости

### Недостатки
- ⚠️ Порядок уведомлений не гарантирован
- ⚠️ Может привести к неожиданным побочным эффектам при множественных уведомлениях

---

## Сравнение: До и после применения паттернов

### До применения паттернов

```python
# Прямое создание объектов
manager = Manager(1, "Иван", "Управление", 100000, 20000)
developer = Developer(2, "Анна", "Разработка", 80000, ["Python"], "senior")

# Жестко закодированный расчет бонусов
def calculate_bonus(employee, bonus_type):
    if bonus_type == "performance":
        return employee.base_salary * 0.1 * rating
    elif bonus_type == "seniority":
        return employee.base_salary * 0.05 * years
    # ...

# Нет системы уведомлений
employee.bonus = 15000  # Изменение происходит без уведомлений
```

**Проблемы:**
- Дублирование кода создания объектов
- Сложность добавления новых типов сотрудников
- Жестко закодированные алгоритмы
- Отсутствие механизма уведомлений

### После применения паттернов

```python
# Использование Factory Method
manager = EmployeeFactoryRegistry.create_employee(
    "manager", id=1, name="Иван", department="Управление",
    base_salary=100000, bonus=20000
)

# Использование Strategy
calculator = BonusCalculator(PerformanceBonusStrategy())
bonus = calculator.calculate(employee, performance_rating=1.5)

# Использование Observer
employee_subject = EmployeeSubject(employee)
employee_subject.attach(NotificationSystem())
employee_subject.notify_salary_change(old_salary, new_salary)

# Использование Singleton
db = DatabaseConnection.get_instance()
conn = db.get_connection()
```

**Преимущества:**
- ✅ Инкапсуляция логики создания объектов
- ✅ Легкое добавление новых типов и стратегий
- ✅ Гибкая система уведомлений
- ✅ Единое подключение к базе данных

---

## Заключение

В ходе выполнения лабораторной работы были успешно реализованы и применены четыре паттерна проектирования:

1. **Singleton** - для управления единственным подключением к базе данных
2. **Factory Method** - для создания объектов сотрудников
3. **Strategy** - для расчета бонусов сотрудников
4. **Observer** - для системы уведомлений об изменениях

### Достигнутые результаты

- ✅ Улучшена архитектура системы учета сотрудников
- ✅ Повышена расширяемость и поддерживаемость кода
- ✅ Снижена связанность между компонентами системы
- ✅ Реализованы проверенные временем решения типичных проблем проектирования

### Выводы

Применение паттернов проектирования позволило:
- Упростить добавление новых типов сотрудников и стратегий расчета
- Обеспечить централизованное управление ресурсами (БД)
- Реализовать гибкую систему уведомлений
- Улучшить читаемость и тестируемость кода

Паттерны проектирования являются мощным инструментом для создания качественного, расширяемого и поддерживаемого программного обеспечения.

---

## Приложения

### Приложение А: Полный код демонстрации паттернов

См. файл `examples/demo_patterns.py`

### Приложение Б: Структура классов паттернов

```
Singleton:
  DatabaseConnection
    ├── __new__() - создание единственного экземпляра
    ├── get_connection() - получение подключения
    └── close_connection() - закрытие подключения

Factory Method:
  EmployeeFactory (ABC)
    ├── ManagerFactory
    ├── DeveloperFactory
    └── SalespersonFactory
  EmployeeFactoryRegistry - реестр фабрик

Strategy:
  BonusStrategy (ABC)
    ├── PerformanceBonusStrategy
    ├── SeniorityBonusStrategy
    └── ProjectBonusStrategy
  BonusCalculator - контекст

Observer:
  Observer (ABC)
    ├── NotificationSystem
    └── EmailNotifier
  Subject (ABC)
    └── EmployeeSubject
```

### Приложение В: Примеры использования

Все примеры использования паттернов находятся в файле `examples/demo_patterns.py` и могут быть запущены командой:

```bash
python examples/demo_patterns.py
```

---

**Конец отчёта**
